# Listas
- Uma **lista** √© uma cole√ß√£o de itens em que cada item tem uma posi√ß√£o relativa em rela√ß√£o aos outros. ‚Üí **Lista Desordenada**. 
- **Listas** podem possuir um primeiro item, um segundo item, um terceiro item e assim por diante. 
- Al√©m disso, √© poss√≠vel se referir ao **in√≠cio da lista** (o **primeiro** item) ou ao **final da lista** (o **√∫ltimo** item).
- Exemplo: A cole√ß√£o dos inteiros 54, 26, 93, 17, 77 e 31 
- **Python**: `[52, 26, 93, 17, 77, 31]` 
## Tipo Abstrato de Dado
- Opera√ß√µes poss√≠veis em uma lista desordenada
- `List()`: **Cria** uma nova lista vazia.  
	- Sem par√¢metros 
	- Retorna uma lista vazia.
- `add(item)`: **Insere** um novo item na lista.  
	- Par√¢metro = item a ser inserido.  
	- Sem retorno  
	- Sup√µe que o item ainda **n√£o est√° na lista**.
- `remove(item)`: **Remove** um item da lista.  
	  - Par√¢metro = item a ser removido.  
	  - A lista √© **modificada**.  
	  - Sup√µe que o item est√° presente na lista.
- `search(item)`: **Procura** um item na lista.  
	  - Par√¢metro = item a ser procurado.  
	 - Retorna um booleano: `True or False`
- `isEmpty()`: verifica se a lista est√° vazia.  
	- Sem Par√¢metros
	- Retorna um booleano: `True or False`
- `size()`: **Retorna** o n√∫mero de itens na lista.  
	- Sem par√¢metros 
	- Retorna um `int`
- `append(item)`: **Adiciona** um novo item ao **final** da lista.  
	- Par√¢metro = item a ser adicionado.
	- Sem retorno  
	- Sup√µe que o item ainda **n√£o est√° na lista**.
- `index(item)`: **Retorna** a **posi√ß√£o** (√≠ndice) do item na lista.  
	- Par√¢metro = item ao qual deseja-se saber sua posi√ß√£o/√≠ndice.
	- Retorna o √≠ndice.  
	- Sup√µe que o item est√° presente na lista.
- `insert(pos, item)`: **Adiciona** um novo item na **posi√ß√£o** `pos` da lista.  
	- Par√¢metro = item a ser inserido e a posi√ß√£o da qual deseja-se inseri-lo
	- Sem retorno  
	- Sup√µe que o **item ainda n√£o est√° na lista** e que a posi√ß√£o `pos` √© **v√°lida**.
- `pop()`: **Remove** e **retorna** o **√∫ltimo item** da lista.  
	- Sem par√¢metros.  
	- Retorna o item removido.  
	- Sup√µe que a lista tem **pelo menos um** item.
- `pop(pos)`: **Remove** e **retorna** o item na **posi√ß√£o** `pos`.  
	- Par√¢metro = posi√ß√£o `pos` da qual deseja-se remover o item.  
	- Retorna o item removido.  
	- Sup√µe que o item est√° presente na lista.
## Implementa√ß√£o de uma Lista Ligada Desordenada
Para implementar uma lista desordenada, usamos uma **lista ligada**. 
- **Objetivo:** manter o **posicionamento relativo** dos itens (n√£o necessariamente na mem√≥ria).
- Se cada item armazenar a **localiza√ß√£o do pr√≥ximo item**, conseguimos manter a ordem relativa.

Exemplos:

 ![Figura 1: Itens dispostos aleatoriamente](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/idea.png)
 
 ![Figura 2: Ordem mantida por links](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/idea2.png)

### Conceitos importantes:
- A **posi√ß√£o do primeiro item** deve ser explicitamente conhecida.
- O primeiro item aponta para o segundo, o segundo para o terceiro, e assim por diante.
- A **refer√™ncia externa** para o primeiro item √© chamada de **cabe√ßa** (_head_) da lista.
- O **√∫ltimo item** indica que **n√£o h√° pr√≥ximo** elemento (geralmente apontando para `null` ou equivalente).

### Classe `Node`
- O bloco b√°sico da lista ligada √© o **n√≥** (`Node`).
#### Cada n√≥ cont√©m:
- Um **campo de dados** (_data field_): armazena o item da lista.
- Uma **refer√™ncia para o pr√≥ximo n√≥**.
```python
class Node:
    def __init__(self, initdata):
        self.data = initdata
        self.next = None
        
    def getData(self):
        return self.data
    
    def getNext(self):
        return self.next

    def setData(self, newdata):
        self.data = newdata

    def setNext(self, newnext):
        self.next = newnext
```

- *Exemplo:* Criando um objeto `Node`
```python
>>> temp = Node(93)
>>> temp.getData()
93
```

- O valor especial `None` representa **aus√™ncia de pr√≥ximo n√≥**.
- No construtor, `next` √© inicialmente configurado para `None` (chamado de **"aterramento do n√≥"**).

 ![Figura 3: Objeto Node](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/node.png)  
 
![Figura 4: Representa√ß√£o t√≠pica de um Node](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/node2.png)

>[!NOTE] 
>Sempre atribua explicitamente `None` para as refer√™ncias iniciais ao criar n√≥s.

### Classe `UnordenedList`
A **lista desordenada** √© constru√≠da como uma **cole√ß√£o de n√≥s** ligados por **refer√™ncias expl√≠citas**.
- Mant√©m **uma √∫nica refer√™ncia** ao **primeiro n√≥**, chamada de **cabe√ßa** (_head_).
```python
class UnorderedList:
    def __init__(self):
        self.head = None
```

- Cria√ß√£o de uma lista
```python
>>> mylist = UnorderedList()
```
- Inicialmente, a lista est√° **vazia** e `self.head` aponta para `None`.

![../_images/initlinkedlist.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/initlinkedlist.png)
![../_images/linkedlist.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/linkedlist.png)

>[!NOTE] 
>A **lista em si n√£o cont√©m objetos `Node`**, apenas uma **refer√™ncia para o primeiro n√≥**

#### M√©todos

##### 1.`isEmpty()`

```python
def isEmpty(self):
    return self.head == None
```
- Retorna `True` se a **cabe√ßa da lista for `None`**.
- √ötil para saber se h√° n√≥s na estrutura.
- Uso de `None` facilita identificar o **in√≠cio e o fim da lista**.
##### 2.`add()`
Para **inserir um novo item** em uma lista desordenada, a localiza√ß√£o espec√≠fica n√£o importa. Assim, optamos pela **inser√ß√£o no in√≠cio da lista** (cabe√ßa), que √© a mais eficiente.
- A lista s√≥ mant√©m uma **refer√™ncia para a cabe√ßa**.
- Inserir no in√≠cio evita a necessidade de percorrer a lista.
- √â suficiente modificar os ponteiros da cabe√ßa.
*Exemplo de Inser√ß√µes:*
```python
>>> mylist.add(31)
>>> mylist.add(77)
>>> mylist.add(17)
>>> mylist.add(93)
>>> mylist.add(26)
>>> mylist.add(54)
```
- O primeiro item adicionado (`31`) acaba como o **√∫ltimo n√≥**.
- O √∫ltimo item adicionado (`54`) se torna o **primeiro n√≥**.

```python
def add(self, item):
    temp = Node(item)          # Cria novo n√≥ com os dados
    temp.setNext(self.head)    # Passo 1: aponta para o antigo primeiro n√≥
    self.head = temp           # Passo 2: atualiza a cabe√ßa da lista
```

 ![Figura 7: Inser√ß√£o Correta](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/addtohead.png)  

**Cuidado com a Ordem dos Passos:**
- Inverter as linhas 3 e 4 **faz perder os n√≥s anteriores**.
- A cabe√ßa era a **√∫nica refer√™ncia externa** ‚Äî perd√™-la significa perder o restante da lista.
 ![Figura 8: Ordem Incorreta](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/wrongorder.png)

> [!NOTE]
> **Varredura de Lista Ligada**
> - A **varredura** refere-se ao processo de **percorrer cada n√≥** da lista a partir da cabe√ßa. Para isso, utilizamos uma **refer√™ncia auxiliar** que √© atualizada com `getNext()`.

##### 3.`size()`
Retorna o n√∫mero de elementos da lista(quantidade de **n√≥s**)
```python
def size(self):
    current = self.head
    count = 0
    while current != None:
        count = count + 1
        current = current.getNext()
    return count
```
- `current`: come√ßa na cabe√ßa da lista.
- Enquanto `current` n√£o for `None`, incrementa o contador.
- Retorna o n√∫mero total de n√≥s.

![../_images/traversal.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/traversal.png)

##### 4.`search()`
Procura um item na lista.Utiliza varredura, mas **pode parar antes do fim** se encontrar o item
```python
def search(self, item):
    current = self.head
    found = False
    while current != None and not found:
        if current.getData() == item:
            found = True
        else:
            current = current.getNext()
    return found
```
- `found` guarda se o item foi encontrado.
- O la√ßo para se `found` for `True` ou se a lista acabar.
- Retorna `True` se encontrar o item, sen√£o `False`.
*Exemplo*
```python
>>> mylist.search(17)
True
```
- A busca por `17` percorre a lista at√© ach√°-lo e para.

![Figura 10: Busca de 17](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/search.png)

##### 5.`remove()`
Remover um **n√≥** que cont√©m um **item espec√≠fico** de uma lista ligada. Assume-se que o item est√° presente na lista.
1. **Busca pelo item**
	- Come√ßamos com um ponteiro `current` apontando para a **cabe√ßa da lista**. 
	- Utilizamos um segundo ponteiro `previous` para acompanhar o **n√≥ anterior ao current**.
	- Enquanto o item **n√£o for encontrado**, fazemos:

```python
previous = current
current = current.getNext()
```

![../_images/removeinit.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/removeinit.png)

![../_images/prevcurr.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/prevcurr.png)

> [!NOTE] 
> Isso garante que, ao encontrar o item, `current` aponta para o n√≥ com o valor desejado, e `previous` aponta para o n√≥ anterior a ele (caso exista).

2. **Remo√ß√£o do n√≥**
	- **Item est√° no primeiro n√≥**
		- `previous` ainda √© `None`
		- Atualizamos a cabe√ßa da lista:
	- **Item est√° no meio ou fim da lista**
		- `previous` aponta para o n√≥ anterior.
		- Ligamos `previous` diretamente ao n√≥ seguinte de `current`, ‚Äúpulando‚Äù `current`:

```python
self.head = current.getNext()
```

```python
previous.setNext(current.getNext())
```

![../_images/remove.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/remove.png)

![../_images/remove2.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/remove2.png)

```python
def remove(self,item):
    current = self.head
    previous = None
    found = False
    
    while not found:
        if current.getData() == item:
            found = True
        else:
            previous = current
            current = current.getNext()

    if previous == None:
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
```

> [!NOTE]
> ### Observa√ß√µes:
> - A ordem de movimenta√ß√£o entre `previous` e `current` √© crucial (‚Äúandar de lesma‚Äù ou _inch-worming_).
> - O m√©todo lida corretamente com:
> 	- remo√ß√£o no in√≠cio da lista,
> 	- remo√ß√£o no meio,
> 	- remo√ß√£o no fim (√∫ltimo n√≥).

##### 6.`append()`
Adiciona um item (um **n√≥**) ao final da lista.  
Esse m√©todo percorre a lista at√© encontrar o √∫ltimo n√≥ (cujo `next` √© `None`) e, ent√£o, adiciona o novo n√≥ ap√≥s ele.

**Dois Casos:**
1. **Lista n√£o vazia**
    - Atravessa a lista desde o primeiro n√≥ (`head`) at√© o √∫ltimo (onde `getNext()` √© `None`).
    - Quando encontra o √∫ltimo n√≥, conecta o novo n√≥ a ele usando `setNext()`.
2. **Lista vazia**
    - A lista n√£o tem nenhum n√≥ (`head` √© `None`).
    - O novo n√≥ se torna o primeiro elemento da lista (ou seja, `head` passa a apontar para ele).

![append-lista](./img/append-lista.png)

```python
def append(self,item):
	temp = Node(item)
	# Caso especial: lista vazia
	if self.head is None:
		self.head = temp
	else:
		current = self.head
		while current.getNext() is not None:
			current = current.getNext()
	current.setNext(temp)
```

##### 7. `index()`
Retorna a **posi√ß√£o** (√≠ndice) do **primeiro n√≥** na lista que cont√©m o item especificado.  
Caso o item **n√£o esteja** na lista, retorna uma mensagem informando isso.

**Dois Casos:**
1. Item est√° presente na lista
    - Percorre a lista do in√≠cio ao fim, comparando cada valor com o item desejado.
    - Quando encontra, retorna a posi√ß√£o atual e encerra a busca.
2. Item **n√£o est√°** presente na lista
    - Percorre toda a lista e, ao final, retorna uma mensagem indicando que o item n√£o foi encontrado.

![index-lista](./img/index-lista.png)

```python
def index(self, item):
	pos = 0
	current = self.head
	while current is not None:
		if current.getData() == item:
			return pos
		current = current.getNext()
		pos += 1
	raise ValueError("item is not in the list")
```

#### 8. `insert(pos, item)`
Insere um item (um **n√≥**) em uma posi√ß√£o espec√≠fica da lista.

Dois casos principais:
1. **Inser√ß√£o na posi√ß√£o 0** (in√≠cio da lista):
    - O novo n√≥ se torna a nova cabe√ßa da lista, apontando para o antigo primeiro n√≥.
2. **Inser√ß√£o em uma posi√ß√£o intermedi√°ria ou final**:
    - Percorre a lista at√© a posi√ß√£o desejada (`pos`).
    - Insere o novo n√≥ entre `previous` e `current`.
**Erro**: Se a posi√ß√£o for maior que o comprimento da lista, levanta uma exce√ß√£o (`ValueError`), como o comportamento do m√©todo `list.insert()` nativo do Python.

![insert1](./img/insert1.png)

![insert2](./img/insert2.png)

```python
def insert(self, pos, item):
	temp = Node(item)
	pos_atual = 0
	current = self.head
	previous = None
	
	# Caso Especial: Inser√ß√£o no in√≠cio
	if pos == 0:
		temp.setNext(self.head)
		self.head = temp
		return
	
	# Percorre at√© a posi√ß√£o desejada
	while current is not None and pos_atual < pos:
		previous = current
		current = current.next
		pos_atual += 1
	
	# Se chegamos na posi√ß√£o correta, insere
	if pos_atual == pos:
		previous.setNext(temp)
		temp.setNext(current)
	else:
		raise ValueError("position doesn't exist in this list")
```

> [!NOTE]
> üìù **Observa√ß√£o:**  
O m√©todo `insert()` da lista nativa do Python permite inserir em qualquer posi√ß√£o at√© `len(lista)`. Se a posi√ß√£o fornecida for maior que o tamanho da lista, o item √© inserido no final.

##### 9. `pop([pos])`
Remove um item da lista.

Dois usos:
1. `pop()` ‚Äî Remove **o √∫ltimo elemento** da lista (como em uma pilha).
2. `pop(pos)` ‚Äî Remove o elemento na **posi√ß√£o indicada**.
- Se `pos == 0`, remove o primeiro elemento.
- Se `pos == len(lista) - 1`, remove o √∫ltimo.
- Se `pos > len(lista) - 1`, lan√ßa um erro.

![lista-pop1](./img/lista-pop1.png)

![lista-pop2](./img/lista-pop2.png)

![lista-pop3](./img/lista-pop3.png)

```python
def insert(self, pos, item):
	temp = Node(item)
	pos_atual = 0
	current = self.head
	previous = None
	
	# Caso Especial: Inser√ß√£o no in√≠cio
	if pos == 0:
		temp.setNext(self.head)
		self.head = temp
		return
	
	# Percorre at√© a posi√ß√£o desejada
	while current is not None and pos_atual < pos:
		previous = current
		current = current.next
		pos_atual += 1
	
	# Se chegamos na posi√ß√£o correta, insere
	if pos_atual == pos:
		previous.setNext(temp)
		temp.setNext(current)
	else:
		raise ValueError("position doesn't exist in this list")
```

> üìù **Observa√ß√£o:**  
> Assim como nas listas nativas do Python, o `pop()` pode opcionalmente receber um √≠ndice. Se n√£o for informado, remove o √∫ltimo item.

### Lista com todos os m√©todos
```python
class Node:
	# Construtor
	def __init__(self,initdata):
		self.data = initdata
		self.next = None
	# M√©todos
	def getData(self):
		return self.data
	def getNext(self):
		return self.next
	def setData(self,newdata):
		self.data = newdata
	def setNext(self,newnext):
		self.next = newnext

class UnorderedList:
	# Construtor
	def __init__(self):
		self.head = None
	# M√©todos
	def isEmpty(self):
		return self.head == None
	
	def add(self,item):
		temp = Node(item)
		temp.setNext(self.head)
		self.head = temp
	
	def size(self):
		current = self.head
		count = 0
		
		while current != None:
			count = count + 1
			current = current.getNext()
		
		return count
		
	def search(self,item):
		current = self.head
		found = False
		
		while current != None and not found:
			if current.getData() == item:
				found = True
			else:
				current = current.getNext()
	
		return found
	
	def remove(self,item):
		current = self.head
		previous = None
		found = False
		
		while not found:
			if current.getData() == item:
				found = True
			else:
				previous = current
				current = current.getNext()
		
		if previous == None:
			self.head = current.getNext()
		else:
			previous.setNext(current.getNext())
	
	def imprimir(self):
		current = self.head
		s = ""
		
		while current != None:
			s = s + " " + str(current.getData())
			current = current.next
		print(s[1:])
		
	def append(self,item):
		temp = Node(item)
		
		# Caso especial: lista vazia
		if self.head is None:
			self.head = temp
		else:
			current = self.head
			while current.getNext() is not None:
				current = current.getNext()
			
			current.setNext(temp)
	
	def index(self, item):
		pos = 0
		current = self.head
		
		while current is not None:
			if current.getData() == item:
				return pos
			current = current.getNext()
			pos += 1
		
		raise ValueError("item is not in the list")
	
	def insert(self, pos, item):
		temp = Node(item)
		pos_atual = 0
		current = self.head
		previous = None
		
		# Caso Especial: Inser√ß√£o no in√≠cio
		if pos == 0:
			temp.setNext(self.head)
			self.head = temp
			return
			
		# Percorre at√© a posi√ß√£o desejada
		while current is not None and pos_atual < pos:
			previous = current
			current = current.next
			pos_atual += 1
		
		# Se chegamos na posi√ß√£o correta, insere
		if pos_atual == pos:
			previous.setNext(temp)
			temp.setNext(current)
		else:
			raise ValueError("position doesn't exist in this list")
	
	def pop(self, pos=None):
		if self.head is None:
			raise ValueError("List is empty")
		
		# Caso: remover o √∫ltimo elemento
		if pos is None:
			
			previous = None
			current = self.head
			
			while current.next is not None:
				previous = current
				current = current.next
		
			if previous is None:
				self.head = None
			else:
				previous.setNext(None)
			
			return current.getData()
		
		# Caso: remover de uma posi√ß√£o espec√≠fica
		previous = None
		current = self.head
		pos_atual = 0
		
		if pos == 0:
			self.head = current.next
			return current.getData()
		else:
			while current is not None and pos_atual < pos:
				previous = current
				current = current.next
				pos_atual += 1
				
			if current is None:
				raise ValueError("Position doesn't exist in this list")
				
			previous.setNext(current.next)
			return current.getData()
```

## Implementa√ß√£o de uma Lista Ligada Ordenada
