# Pilhas
- Uma **pilha** (_stack_) √© uma **cole√ß√£o ordenada** de itens onde a **inser√ß√£o** de novos itens e a **remo√ß√£o** de itens existentes sempre ocorrem **na mesma extremidade**
- Essa extremidade √© chamada de **topo**,enquanto a extremidade oposta √© chamada de **base** 
- Segue o princ√≠pio de ordena√ß√£o **LIFO**(*last in first out*).
- Ou seja, O **√∫ltimo item inserido** √© aquele que est√° na posi√ß√£o em que pode ser **removido primeiro**
- Enquanto,Os itens armazenados na pilha que est√£o **mais perto da base** s√£o aqueles que est√£o na **pilha a mais tempo**
- Os itens est√£o armazenados de acordo com o **tempo de perman√™ncia** na estrutura. 
	- Itens **recentemente inseridos** na estrutura est√£o mais **.**
	- itens **mais antigos** na estrutura est√£o **perto da base**.

*Exemplo*:
> [!note] 
>Pilha de bandejas,Pilha de livros...
>Navegador: bot√£o `Voltar`(*Back*)
>- √Ä medida que voc√™ navega de uma p√°gina web para outra p√°gina, essas **p√°ginas** s√£o colocadas em uma **pilha** (na verdade, s√£o as **URLs** que v√£o para a pilha). 
>- A **p√°gina atual** que voc√™ est√° visualizando est√° no **topo** e a **primeira p√°gina** que voc√™ olhou est√° na **base**. Se voc√™ clicar no bot√£o `Voltar`, voc√™ come√ßa a se mover pelas p√°gina na **ordem inversa**

![pilha-ex1](./img/pilha-ex1.png)

![pilha-ex2](./img/pilha-ex2.png)

- A ordem que eles s√£o *removidos* √© exatamente a **inversa da ordem** em que foram *colocados*. 
- As **pilhas** podem ser usadas para **reverter** a *ordem dos itens*. 
- A *ordem de inser√ß√£o* √© a **inversa** da *ordem de remo√ß√£o*

![pilha-ex3](./img/pilha-ex3.png)

### Tipo Abstrato de Dado
- `Stack()`: **Cria** uma nova pilha
	- Sem par√¢metros
	- retorna uma pilha vazia
- `push(item)`: **Insere** um elemento na pilha (*Empilhar*)
	- Necessita do item a ser inserido
	- Sem retorno
- `pop()`: **Remove** o item que est√° no **topo** da pilha (*Desempilhar*)
	- Sem par√¢metro
	- Retorna o item removido
	- A pilha √© **modificada**
- `peek()`: **Retorna** o item no **topo** da pilha mas **n√£o** o **remove** da pilha
	- Sem par√¢metros
	- A pilha **n√£o** √© **modificada** 
- `isEmpty()`: **Testa** se a pilha est√° **vazia**
	- Sem Par√¢metros
	- Retorna um booleano: `True or False`
- `size()`: **Retorna** o **n√∫mero de itens** na pilha
	- Sem par√¢metros 
	- Retorna um `int`

| Opera√ß√µes     | Conte√∫do da Pilha     | Valor retornado |
| ------------- | --------------------- | --------------- |
| s.isEmpty()   | []                    | True            |
| s.push(4)     | [4]                   |                 |
| s.push('dog') | [4, 'dog']            |                 |
| s.peek()      | [4, 'dog']            | 'dog'           |
| s.push(True)  | [4, 'dog', True]      |                 |
| s.size()      | [4, 'dog', True]      | 3               |
| s.isEmpty()   | [4, 'dog', True]      | False           |
| s.push(8.4)   | [4, 'dog', True, 8.4] |                 |
| s.pop()       | [4, 'dog', True]      | 8.4             |
| s.pop()       | [4, 'dog']            | True            |
| s.size()      | [4, 'dog']            | 2               |

## Implementa√ß√£o de uma Pilha
- A implementa√ß√£o de um tipo abstrato de dados como uma pilha √© feita atrav√©s da cria√ß√£o de uma nova **classe**
- Consequentemente, as **opera√ß√µes** sobre uma pilha s√£o implementadas como **m√©todos**
- Al√©m disso, para implementar uma pilha, que √© uma cole√ß√£o de elementos, usaremos uma lista (`list`) e seus m√©todos.
 - Contudo,√© preciso decidir qual **extremidade da lista** ser√° considerado o **topo** da pilha e qual ser√° a **base**
```python
# Pilha implementada usando o final da lista como topo.
# --> Os novos items ser√£o inseridos ao final da lista
class Stack:
	# Construtor
	def __init__(self):
		self.itens = []
	# M√©todos
	def isEmpty(self):
		return self.itens == []
	def push(self,item):
		return self.itens.append(item)
	def pop(self):
		return self.itens.pop()
	def peek(self):
		return self.itens[-1]
	def size(self):
		return len(self.itens)
```

>[!note]
>- O m√≥dulo `pythonds` cont√©m **implementa√ß√µes** de todas as estruturas de dados discutidas neste livro. 
>- Est√° estruturado de acordo com as se√ß√µes: b√°sico, √°rvores e grafos. O m√≥dulo pode ser baixado de [pythonworks.org](http://www.pythonworks.org/pythonds).

```python
# from pythonds.basic.stack import Stack
# Exemplo
s = Stack()
print(s.isEmpty())
s.push(4)
s.push('Dog')
print(s.peek())
s.push(True)
print(s.size())
print(s.isEmpty())
s.push(8.4)
print(s.pop())
print(s.pop())
print(s.size())
```

- Poder√≠amos implementar uma pilha usando uma lista em que o **topo** estaria no **in√≠cio** e **n√£o** no final 
- Neste caso, seria necess√°rio alterar os m√©todos `append()` e `pop()`.
	- `append()` ‚Üí `insert(0,item)`  
	- `pop()` ‚Üí `pop(0)`

```python
# Pilha implementada usando o inicio da lista como topo.
# --> Os novos items ser√£o inseridos e removidos no inicio da lista
class Stack:
	# Construtor
	def __init__(self):
		self.itens = []
	# M√©todos
	def isEmpty(self):
		return self.itens == []
	def push(self,item):
		return self.itens.insert(0,item)
	def pop(self):
		return self.itens.pop(0)
	def peek(self):
		return self.itens[0]
	def size(self):
		return len(self.itens)
```

>[!NOTE]
> - 1¬∫ Implementa√ß√£o: Cada execu√ß√£o de `push()` e `pop()` consome **tempo constante**,$O(1)$, **independentemente** do **n√∫mero de itens** na pilha, j√° que `append()` e `pop()` s√£o opera√ß√µes que consomem **tempo constante**.
> - 2¬∫ Implementa√ß√£o:O consumo de tempo de `push()` e `pop()` √© **proporcional** ao **n√∫mero n de itens** na pilha j√° que as opera√ß√µes `insert(0)` e `pop(0)` requererem tempo $O(n)$. 
### Exemplos:
#### Par√™nteses Balanceados
- **Problema:**  Verificar se uma express√£o matem√°tica cont√©m apenas par√™nteses `()` corretamente balanceados, ou seja, se cada par√™ntese de abertura `(` possui um correspondente de fechamento `)` na ordem adequada.
- **Ideia de solu√ß√£o:**
	- Percorrer a string da express√£o caractere por caractere.
	- Sempre que um par√™ntese de **abertura** `(` for encontrado, ele √© adicionado √† pilha.
	- Quando um par√™ntese de **fechamento** `)` for encontrado, √© necess√°rio verificar:
		- Se a pilha estiver **vazia**, significa que n√£o h√° um par√™ntese de abertura correspondente ‚Üí **inv√°lido**.
		- Caso contr√°rio, remove-se um elemento da pilha (par√™ntese de abertura correspondente).
	- Ao final, se a pilha estiver **vazia**, os par√™nteses est√£o corretamente balanceados ‚Üí **v√°lido**.

| Express√£o     | Resultado  |
| ------------- | ---------- |
| (4 x 3)       | ‚úÖ V√°lido   |
| )4 x 3(       | ‚ùå Inv√°lido |
| ((3 + 2)      | ‚ùå Inv√°lido |
| (1 + (2 * 3)) | ‚úÖ V√°lido   |
| ()(()())      | ‚úÖ V√°lido   |

![Par√™nteses Balanceados](./img/parenteces-balanceados.png)

```python
# Exemplo1: Par√™nteces Balanceados
def ehBalanceado(equacao):
	pilha = Stack()
	for i in equacao:
		if i == "(":
			pilha.push(i)
		elif i == ")":
			if pilha.isEmpty():
				return False
			else:
			pilha.pop()
	return pilha.isEmpty()
equacao = "( ( ( ) ) ) )"
print(ehBalanceado(equacao))
```
#### S√≠mbolos Balanceados
- **Problema:**  Verificar se uma express√£o matem√°tica possui os par√™nteses ‚Äî `()`, `[]`, `{}` ‚Äî corretamente balanceados, ou seja, se cada s√≠mbolo de abertura possui um correspondente de fechamento na ordem adequada.
- **Ideia de solu√ß√£o:**
    - Percorrer a string da express√£o caractere por caractere.
    - Sempre que um s√≠mbolo de **abertura** (`(`, `[`, `{`) for encontrado, ele √© adicionado √† pilha.
    - Quando um s√≠mbolo de **fechamento** (`)`, `]`, `}`) for encontrado, √© necess√°rio verificar:
        - Se a pilha est√° **vazia**, significa que n√£o h√° s√≠mbolo de abertura correspondente ‚Üí **inv√°lido**.
        - Se o topo da pilha **n√£o corresponde** ao s√≠mbolo de abertura equivalente, a estrutura est√° incorreta ‚Üí **inv√°lido**.
    - Ao final, se a pilha estiver **vazia**, todos os s√≠mbolos foram corretamente balanceados ‚Üí **v√°lido**.

| Express√£o             | Resultado  |
| --------------------- | ---------- |
| (4 x 3)               | ‚úÖ V√°lido   |
| )4 x 3(               | ‚ùå Inv√°lido |
| ({3 x 4)}             | ‚ùå Inv√°lido |
| {(3 x 4) - 1} x 2     | ‚úÖ V√°lido   |
| {[(12 - 1) + 2] x 10} | ‚úÖ V√°lido   |

![S√≠mbolos Balanceados](./img/simbolos-balanceados.png)

```python
# Exemplo2: S√≠mbolos Balanceados
def ehBalanceado(equacao):
	s = Stack()
	for i in equacao:
		if i == "{" or i == "[" or i == "(":
			s.push(i)
		elif i == "}" and (s.isEmpty() or s.pop() != "{"):
			return False
		elif i == "]" and (s.isEmpty() or s.pop() != "[" ):
			return False
		elif i == ")" and (s.isEmpty() or s.pop() != "("):
			return False
	return s.isEmpty()

equacao = "{[(12-1)+2]*10}"
print(ehBalanceado(equacao))
```

#### S√≠mbolos Correspondentes
- **Problema:** Dada uma lista de express√µes alg√©bricas v√°lidas, verificar se h√° algum s√≠mbolo de prioridade duplicado dentro de cada express√£o.Exemplo: 5‚àó((1001+110)) √© equivalente a 5‚àó(1001+110)  
*Exemplo*:  A express√£o `5‚àó((1001+110))` possui par√™nteses duplicados, pois `((1001+110))` poderia ser reescrito como `(1001+110)` sem alterar o significado. 
- **Ideia de Solu√ß√£o:**
    1. Percorrer cada caractere da express√£o:
        - Se for um s√≠mbolo de abertura (`(`, `[`, `{`), empilhar.
        - Se for um s√≠mbolo de fechamento (`)`, `]`, `}`):
            - Verificar o topo da pilha:
                - Se o topo for o s√≠mbolo de abertura correspondente, significa que n√£o havia nada relevante entre o par de s√≠mbolos ‚Äî logo, h√° duplica√ß√£o.
                - Caso contr√°rio, desempilhar todos os elementos at√© encontrar o s√≠mbolo de abertura correspondente, eliminando assim o conte√∫do j√° verificado.                    
    2. Se algum caso de duplica√ß√£o for encontrado, a fun√ß√£o retorna `True`. Caso contr√°rio, retorna `False`.

![Parenteces Correspondentes](./img/simbolos-correspondentes.png)

```python
def duplicada(simb_abre, simb_fecha, expressao):
    pilha = Stack()
    for caracter in expressao:
        if caracter == simb_fecha:
            if pilha.peek() == simb_abre:
                # Par√™nteses imediatamente fechados: duplica√ß√£o
                return True
            else:
                while pilha.peek() != simb_abre:
                    pilha.pop()
                pilha.pop()  # Remove o s√≠mbolo de abertura tamb√©m
        else:
            pilha.push(caracter)
    return False
```
#### Convers√£o de Decimal para Bin√°rio
- **Como converter Decimal ‚Üí Bin√°rio?**
    - **Algoritmo de Divis√£o por 2:**
        - Enquanto o n√∫mero decimal for maior que 0:
            - Divida por 2, guarde o **resto** em uma **pilha**.
            - O primeiro resto calculado ser√° o **√∫ltimo d√≠gito** do bin√°rio (menos significativo).
        - Ao final, desempilhe todos os restos para formar o n√∫mero bin√°rio.
- **Por que usar uma pilha?**
    - A pilha reverte a ordem dos restos, garantindo a sequ√™ncia correta dos d√≠gitos bin√°rios.
![decimal-binario](./img/decimal-binario.png)

```python
def divide_2(num_decimal):
    s = Stack()
    while num_decimal > 0:
        s.push(num_decimal % 2)
        num_decimal = num_decimal // 2
    # Impressao
    binString = ""
    while not s.isEmpty():
        binString += str(s.pop())
    return binString

print(divide_2(10))  # Sa√≠da: 1010
```
#### Convers√£o de Decimal para Qualquer Base (2 a 16)
- O mesmo algoritmo pode ser adaptado para converter para **qualquer base** (bin√°rio, octal, hexadecimal etc.).
- Basta substituir a divis√£o por 2 pela divis√£o pela **base desejada**
- Para bases acima de 10, utilizamos letras (`A` a `F`) para representar os valores.
**Exemplo de convers√£o:**
- `233` decimal = `351` octal = `E9` hexadecimal.
```python
def conversaoBase(num_decimal, base):
    s = Stack()
    while num_decimal > 0:
        s.push(num_decimal % base)
        num_decimal = num_decimal // base
    # Impress√£o
    digitos = "0123456789ABCDE"
    newString = ""
    while not s.isEmpty():
        newString += digitos[s.pop()]
    return newString

print(conversaoBase(25, 2))   # Sa√≠da: 11001
print(conversaoBase(25, 16))  # Sa√≠da: 19
```

#### Express√µes Infixas, Prefixas e Posfixas
- **Infixas:** O operador aparece entre os dois operandos sobre os quais est√° atuando.
- Cada operador tem seu n√≠vel de **preced√™ncia**. 
	- Operadores de *maior* preced√™ncia s√£o aplicados **antes** de operadores de *menor* preced√™ncia. 
	- **Par√™nteses** ‚Üí muda essa ordem de preced√™ncia. 
	- \*,/ > +,- . 
	- Se dois operadores de preced√™ncia igual aparecem um ap√≥s outro √© utilizada uma ordena√ß√£o ou associatividade da _esquerda para a direita_.
- Uma maneira de escrever uma express√£o que garanta que n√£o haver√° confus√£o alguma com respeito a ordem em que as opera√ß√µes s√£o executadas √© criar uma express√£o **totalmente parametrizada**.
- Este tipo de express√£o usa um **par de par√™nteses** para cada **operador**. Os par√™nteses ditam a **ordem** em que as **opera√ß√µes s√£o executadas**.
*Exemplo:* A + B * C + D ‚Üí ((A + (B * C)) + D) ; A + B + C + D ‚Üí (((A + B) + C) + D)
- **Prefixas**: Requer que todos os operadores **precedam** os dois **operandos** sobre os quais atuam
- **Posfixas**: Requer que seus operadores venham **depois** dos **operandos** correspondentes

>[!NOTE]
>As express√µes **prefixas** e **posfixas** n√£o requerem paranteceses para delimitar a preced√™ncia somente as **infixas**

| **Express√£o Infixa** | **Express√£o Prefixa** | **Express√£o Posfixa** |
| -------------------- | --------------------- | --------------------- |
| A + B                | + A B                 | A B +                 |
| A + B * C            | + A * B C             | A B C * +             |
| (A + B) * C          | * + A B C             | A B + C *             |
| A + B * C + D        | + + A * B C D         | A B C * + D +         |
| (A + B) * (C + D)    | * + A B + C D         | A B + C D + *         |
| A \* B + C \* D      | + * A B * C D         | A B \* C D \* +       |
| A + B + C + D        | + + + A B C D         | A B + C + D +         |
#### Convers√£o Infixas ‚Üí Prefixas e Posfixas
- T√©cnica: Express√£o entre par√™nteses 
	- A + B * C ‚Üí (A + (B * C))
	- Cada **par de par√™nteses** tamb√©m determina o **in√≠cio e o fim** de um **par de operandos** com o operador correspondente no meio.
	- Ao mover o operador para a posi√ß√£o do **par√™ntese direito** e **remover o par√™ntese esquerdo**, a subexpress√£o √© convertida para a nota√ß√£o p√≥s-fixa. Fazendo isso para todos os operadores, obt√©m-se a express√£o p√≥s-fixa completa
	
![Convers√£o Posfixa](./img/conversao-posfixa.png)

- Se fizermos a mesma coisa, mas em vez de mover o s√≠mbolo para a posi√ß√£o do par√™ntese direito, n√≥s o movemos para a esquerda, obtemos a nota√ß√£o prefixa.

![../_images/moveleft.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/moveleft.png)

Express√£o complexa: (A + B) * C - (D - E) * (F + G)

![../_images/complexmove.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/complexmove.png)

#### üìú Algoritmo de Convers√£o Infixa ‚Üí P√≥s-Fixa
1. **Inicializa√ß√£o**:
    - Cria uma pilha vazia (`s`)
    - Cria uma lista vazia para a express√£o p√≥s-fixa (`expressao_posfixa`)
    - Inicializa o √≠ndice em 0 para percorrer a express√£o
2. **Processamento de cada caractere**:
    - Para cada caractere na express√£o de entrada:  
        a. **N√∫meros multi-d√≠gitos**: Verifica se o caractere atual e o pr√≥ximo s√£o d√≠gitos, concatenando-os  
        b. **Operadores (+, -, *, /)**:
        - Para `+` e `-`: desempilha todos os operadores at√© encontrar "(" ou a pilha esvaziar
        - Para `*` e `/`: desempilha apenas o topo da pilha (preced√™ncia maior)
        - Empilha o novo operador  
            c. **Par√™ntese esquerdo "("**: Simplesmente empilha  
            d. **Par√™ntese direito ")"**: Desempilha tudo at√© encontrar o "(" correspondente  
            e. **Outros casos (n√∫meros)**: Adiciona diretamente √† sa√≠da
3. **Finaliza√ß√£o**:    
    - Desempilha todos os operadores restantes na pilha
    - Retorna a express√£o p√≥s-fixa

![algoritmo-posfixa](./img/algoritmo-posfixa.png)

```python
def posfixa(equacao):
	s = Stack()
	expressao_posfixa = [] # Sa√≠da final da express√£o
	index = 0
	while index < len(equacao):
		caracter = equacao[index]
		# Juntar caracteres com mais de um digito
		if caracter.isdigit():
			while (index + 1 < len(equacao)) and equacao[index+1].isdigit():
				caracter += equacao[index + 1]
				index += 1
			expressao_posfixa.append(caracter)
		elif caracter in "+-*/":
			# Determinar preced√™ncia
			prec_caracter = 1 if caracter in '+-' else 2
			while (not s.isEmpty()) and (s.peek() != "("):
				prec_topo = 1 if s.peek() in '+-' else 2
				if prec_topo >= prec_caracter:
					expressao_posfixa.append(s.pop())
				else:
					break
			s.push(caracter)
		elif caracter == "(":
			s.push(caracter)
		elif caracter == ")":
			while not s.isEmpty() and s.peek() != "(":
				expressao_posfixa.append(s.pop())
			s.pop() # Remove o "(" da pilha
		index += 1
		
# Desempilha todos os operadores restantes
	while not s.isEmpty():
		expressao_posfixa.append(s.pop())
		
return expressao_posfixa
```
#### Calculadora
Para avaliar uma express√£o em nota√ß√£o p√≥s-fixa (posfixa), usamos uma pilha. Durante a leitura da express√£o da esquerda para a direita:
- **Operandos** s√£o empilhados.
- **Operadores** acionam a retirada (`pop()`) dos dois operandos mais recentes para aplicar a opera√ß√£o.
- O resultado √© ent√£o empilhado novamente.

*Exemplo:* 4 5 6 * +
- Empilha 4 e 5.
- Empilha 6.
- Ao encontrar `*`, multiplica 5√ó6 = 30 e empilha o resultado.    
- Ao encontrar `+`, soma 4+30 = 34.

![../_images/evalpostfix1.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/evalpostfix1.png)

*Exemplo:* 7 8 + 3 2 + /

![../_images/evalpostfix2.png](https://panda.ime.usp.br/pythonds/static/pythonds_pt/_images/evalpostfix2.png)

```python
def calcula(posfixa):
	s = Stack()
	for c in posfixa:
		if c == "+":
			operando2 = s.pop()
			operando1 = s.pop()
			s.push(operando1 + operando2)
		elif c == "-":
			operando2 = s.pop()
			operando1 = s.pop()
			s.push(operando1 - operando2)
		elif c == "*":
			operando2 = s.pop()
			operando1 = s.pop()
			s.push(operando1 * operando2)
		elif c == "/":
			operando2 = s.pop()
			operando1 = s.pop()
			s.push(operando1 / operando2)
		else:
			s.push(int(c))
	return s.pop()
```